<html>  
    <head>  
        <link rel="stylesheet" href="style.css">
    </head>
    <div class="topnav">
        <img class = "logo" src = "Logo(NBG).png" height="50px" border-radius="25px">
        <a href="index.html">Home</a>
        <a class="active" href="content.html">Content</a>
        <a href="about.html">About</a>
        <a href="quiz.html">Quiz</a>
    </div> 

   <div class = content>
   <h2>Computational Thinking</h2>
    </div>


 
    <style>
         .carousel-frame {
     width: 100%;
     margin-bottom: 0.5em;
     padding-bottom: 1em;
     position: relative;
     overflow-x: scroll;
     white-space: nowrap;
     }
    .carousel-frame ul {
      margin: 0;
      padding: 0;
       list-style: none;
      /*position: fixed;
      top: 0;*/ 
    }


    h1 {
        border: 1px solid black;
        padding: 5px;
        display: inline-block;
        font-family: Verdana, Tahoma, sans-serif;
        color: rgb(43, 43, 43);
        text-decoration: none;
        font-size: 22px;
    }
    
    h3 {
      font-family: Verdana, Tahoma, sans-serif;
      text-decoration: underline;
      text-align: center;
    }

    div.scrollmenu {
  overflow: auto;
  text-align: center;
  white-space: nowrap;
}

div.scrollmenu a {
  display: inline-block;
  text-align: center;
  padding: 5px;
  text-decoration: none;
}

div.scrollmenu a:hover {
  background-color: #777;
}

    </style>

    <body>
      <div class="scrollmenu">
              <a href="#intro"> <h1>Introduction</h1></a>
               <a href="#algorithms"> <h1>Algorithms</h1></a>
            <a href="#abstraction"> <h1>Abstraction</h1></a>
            <a href="#complexity"> <h1>Algorithm Complexity</h1></a>
            <a href="#recursion"> <h1>Recursion</h1></a>
      </div>
    
      
   <div id="intro">
    <h3>What is Computational Thinking?</h3>
    <p>
      Computational thinking is a problem-solving approach that involves breaking down complex problems into smaller, more manageable parts, and using algorithms and logical reasoning to solve them. It's a way of thinking that is closely related to the way computer scientists and engineers approach problems.
      <br>
      <br>
      At its core, computational thinking involves four key elements: decomposition, pattern recognition, abstraction, and algorithmic thinking. Decomposition involves breaking a problem down into smaller parts or steps, while pattern recognition involves identifying similarities and patterns in those parts. Abstraction involves focusing on the important details and ignoring the irrelevant ones, and algorithmic thinking involves developing a step-by-step plan to solve the problem.
      <br>
      <br>
      Computational thinking is not just about solving problems with computers, but rather about developing the skills and thought processes needed to solve problems in any field or domain. It is a valuable skill for anyone who needs to solve complex problems, whether they are in computer science, engineering, math, science, or any other field. By applying computational thinking to a problem, you can break it down into manageable pieces, identify patterns, and develop algorithms to solve it more efficiently and effectively.
    </p>
<hr>
    <div id="algorithms">
      <h3>Algorithms</h3>
      <p>
        When it comes to describing, reading and creating algorithms, there are several tools and techniques that can be used. One such tool is the flowchart, which is a graphical representation of an algorithm that uses symbols to represent different steps and decision points. Another tool is pseudocode, which is a high-level description of an algorithm that uses a combination of natural language and programming language syntax.
        <br>
        <br>
        
Decomposition is another important technique that involves breaking down a problem into smaller, more manageable parts or sub-problems. Loops are another programming construct that allows a set of instructions to be repeated multiple times until a certain condition is met. There are different kinds of loops, such as for loops, while loops, and do-while loops.
<br>
<br>

Stepwise refinement is a process of repeatedly refining and breaking down an algorithm into smaller and more detailed steps until it is completely specified. Generalization, on the other hand, involves taking a specific algorithm and making it more general, so that it can be applied to a wider range of related problems.
<br>
<br>

Testing and scrutinising are also crucial steps in creating and describing algorithms. Once an algorithm has been developed, it is important to test it thoroughly to ensure that it works correctly and efficiently. This may involve testing it with different inputs, edge cases, and scenarios, as well as scrutinizing the algorithm and its description to identify any errors or areas for improvement.
      </p>
      <hr>
      <div id="abstraction">
        <h3>Abstraction</h3>
        <p>
          Abstraction is a fundamental concept in computer science that involves focusing on the essential features of a problem or system while ignoring unnecessary details. It involves creating models and representations of complex systems or processes that capture only the most important aspects of their behavior.
          <br>
          <br>

Abstraction is important in computer science for several reasons. First, it allows us to manage complexity by breaking down a problem or system into smaller, more manageable parts. By focusing only on the most important details, we can reduce the complexity of a problem and make it easier to solve.
<br>
<br>

Second, abstraction allows us to create reusable and modular software components. By creating abstractions of common tasks or functionality, we can build libraries of reusable code that can be used in multiple applications or systems. This not only saves time and effort but also improves the reliability and maintainability of software systems.
<br><br>

Third, abstraction facilitates communication and collaboration between developers and stakeholders. By creating simple, high-level models of a system or process, we can more easily communicate its behavior and requirements to others, even if they do not have a deep technical understanding of the system.
<br><br><br>

Below is an example of abstraction being used in pictures. An image contains many varying elements such as colour, shape and texture which is alot of information to process. This is why abstraction is used to eliminate some of these elements in order to reduce the amount of data to be processed. In this example the previous mentioned elements can be removed while retaining a representation of the original image. For a more detailed explanation visit <a href="https://ieeexplore.ieee.org/abstract/document/4522547/">HERE.</a>
<br>
<div id="figure1">
  <img src="abstrationExample1.jpeg" alt="Boat Abstraction Process">
</div>
<br>
<a href="#figure1"> Fig.1.</a> An image being abstracted in different ways with (a) being the original image. Source by "Kang, H., Lee, S. and Chui, C.K., 2008. Flow-based image abstraction. IEEE transactions on visualization and computer graphics, 15(1), pp.62-76."

<br><br><br>

In conclusion, abstraction is important for enabling innovation and creativity. By abstracting away the details of a problem or system, we can focus on the big picture and explore new ideas and approaches to solving complex problems.
        </p>
        <hr>
        <div id="complexity">
          <h3>Algorithm Complexity</h3>
          <p>
            Algorithm complexity refers to the amount of resources, such as time and memory, required to execute an algorithm as the size of the input increases. The complexity of an algorithm is usually measured in terms of the "big O" notation, which describes the upper bound of the growth rate of the algorithm's resource consumption.
            <br>
            <br>

The time complexity of an algorithm is the amount of time it takes to execute as a function of the size of the input. It is usually measured in terms of the number of operations or steps performed by the algorithm. For example, an algorithm that takes n steps to complete has a time complexity of O(n).
<br>
<br>

The space complexity of an algorithm is the amount of memory it requires to execute as a function of the size of the input. It is usually measured in terms of the amount of memory used by the algorithm's data structures and variables. For example, an algorithm that requires a fixed amount of memory regardless of the input size has a space complexity of O(1).
<br>
<br>

The goal of analyzing algorithm complexity is to identify algorithms that are efficient and scalable for large inputs. An algorithm with a lower complexity, such as O(log n) or O(n), is generally considered more efficient than one with a higher complexity, such as O(n^2) or O(2^n).
          </p>
          <hr>
          <div id="recursion">
            <h3>Recursion</h3>
            <p>
              Recursion is a programming technique in which a function calls itself one or more times in order to solve a problem or perform a task. It is a powerful and flexible approach that can be used to solve a wide range of problems in computer science and mathematics.
              <br>
              <br>

When a function calls itself, it creates a new instance of the function on the call stack, with its own set of local variables and parameters. Each recursive call operates on a smaller subset of the original problem, until a base case is reached, at which point the function returns a value to the previous call, and the stack begins to unwind.
<br>
<br>

Recursion can be used to solve problems that have a recursive structure, such as searching through a tree or graph, computing a factorial or Fibonacci sequence, or traversing a maze. It can also be used to implement certain algorithms, such as quicksort and merge sort, that involve dividing a problem into smaller sub-problems.
<br>
<br>

Recursion has several advantages over iterative approaches, including simplicity, elegance, and generality. However, it can also be less efficient than iterative approaches in terms of time and space complexity, due to the overhead of function calls and stack management.
<br>
<br>

In order to use recursion effectively, it is important to carefully define the base case and ensure that the function always makes progress towards the base case. It is also important to consider the potential for stack overflow and other issues related to function call depth and memory usage.
            </p>
   </div>

</html>

<footer>
  <p>&copy;2023<br>
    University of Manchester, Oxford Road<br>
    Manchester, M13 9PR</p>
  <a href="#top">Back to top</a>
</footer>

